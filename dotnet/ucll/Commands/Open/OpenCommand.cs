class OpenCommand(PlatformSupport platformSupport, UnityHub unityHub) : BaseCommand<OpenSettings>
{
	protected override int ExecuteImpl(OpenSettings settings)
	{
		string searchPath = settings.SearchPath ?? PromptForRecentProject(settings.Favorite, unityHub);

		searchPath = Path.GetFullPath(searchPath);

		if (!Directory.Exists(searchPath) && !File.Exists(searchPath))
		{
			WriteError($"'{searchPath}' does not exist.");
			return 1;
		}

		UnityVersion unityVersion = ProjectVersionFile.Parse(searchPath, out string filePath);
		Debug.WriteLine($"File: {filePath}\n{unityVersion}\nVersion: {unityVersion}");

		unityHub.InstallEditorChecked(unityVersion.Version, unityVersion.Changeset, settings.MutatingProcess);

		string editorPath = unityHub.GetEditorPath(unityVersion.Version);
		AnsiConsole.MarkupLine($"[dim]Editor: {editorPath}[/]");

		string projectDir = new FileInfo(filePath).Directory!.Parent!.FullName;
		string[] additionalArgs = context.Remaining.Raw.ToArray();
		var args = new List<string> { "-projectPath", projectDir };
		args.AddRange(additionalArgs);

		settings.MutatingProcess.Run(new ProcessStartInfo(fileName: editorPath, arguments: JoinQuoted(args)));

		if (settings.CodeEditor)
		{
			OpenSolutionFile(projectDir, settings.MutatingProcess);
		}

		// Unity doesn't report an exit code if the editor fails to open a project.
		// Instead, it prints error into the log. So, for now, we must assume it succeeded.
		return 0;
	}

	private static string JoinQuoted(List<string> args)
	{
		return string.Join(" ", args.Select(a => a.Contains(' ') ? $"\"{a}\"" : a));
	}

	public static string PromptForRecentProject(bool favoritesOnly, UnityHub unityHub)
	{
		string[] recentProjects = unityHub.GetRecentProjects(favoritesOnly).ToArray();

		if (recentProjects.Length == 0)
			throw new UserException("No projects found in Unity Hub.");

		return SelectionPrompt.Prompt(
			recentProjects,
			$"Select a {(favoritesOnly ? "favorite" : "recent")} project: ");
	}

	private void OpenSolutionFile(string projectDir, IProcessRunner processRunner)
	{
		// Files might need to be generated by Unity (e.g. first project open).
		string solutionFile = WaitForFileAsync(projectDir, "*.sln").Result;
		AnsiConsole.MarkupLine($"[dim]Solution: {Path.GetFileName(solutionFile)}[/]");

		foreach (var strategy in OpenSolutionStrategies())
		{
			try
			{
				ProcessStartInfo? processInfo = strategy.Invoke(solutionFile);
				if (processInfo != null)
				{
					var process = processRunner.Run(processInfo);
					process.WaitForExit();
					if (process.ExitCode == 0)
						break;
				}
			}
			catch (Exception e)
			{
				WriteError(e);
			}
		}
	}

	private IEnumerable<Func<string, ProcessStartInfo?>> OpenSolutionStrategies()
	{
		yield return OpenWithUnityDefault;
		yield return platformSupport.OpenFile;
	}

	private ProcessStartInfo? OpenWithUnityDefault(string solutionFile)
	{
		string? scriptingEditor = platformSupport.GetUnityScriptingEditorPath();

		// Handle executables or app bundles.
		if (File.Exists(scriptingEditor) || Directory.Exists(scriptingEditor))
		{
			return platformSupport.OpenFileWithApp(solutionFile, scriptingEditor);
		}
		return null;
	}

	/// <summary>
	/// Returns as soon as a file found by the pattern exists in the directory.
	/// </summary>
	private static async Task<string> WaitForFileAsync(string projectDir, string searchPattern)
	{
		string? path = Directory.GetFiles(projectDir, searchPattern, SearchOption.TopDirectoryOnly).FirstOrDefault();
		if (path != null)
			return path;

		var tcs = new TaskCompletionSource<string>();
		using var watcher = new FileSystemWatcher(projectDir, searchPattern);
		watcher.Created += (_, e) => tcs.TrySetResult(e.FullPath);
		watcher.EnableRaisingEvents = true;
		return await tcs.Task;
	}
}